#!/usr/bin/env node
"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs-extra");
var serializer = require("js-yaml");
var program = require("commander");
var parser_1 = require("./parser");
var postTransformer_1 = require("./postTransformer");
var tocGenerator_1 = require("./tocGenerator");
var packageGenerator_1 = require("./packageGenerator");
var idResolver_1 = require("./idResolver");
var constants_1 = require("./common/constants");
var flags_1 = require("./common/flags");
var context_1 = require("./converters/context");
var pjson = require('../package.json');
var path;
var outputPath;
var repoConfigPath;
program
    .version("v" + pjson.version)
    .description('A tool to convert the json format api file generated by TypeDoc to yaml format output files for docfx.')
    .option('--hasModule', 'Add the option if the source repository contains module.')
    .option('--disableAlphabetOrder', 'Add the option if you want to disable the alphabet order in output yaml.')
    .option('--tocAlphabetOrderOnly', 'Add the option if you want to enable alphabet order only in the TOC in output yaml.')
    .option('--basePath [value]', 'Current base path to the repository.')
    .option('--sourceUrl [value]', 'Define the source repository address.')
    .option('--sourceBranch [value]', 'Define the branch of source repository.')
    .arguments('<inputFile> <outputFolder> [repoConfigureFile]')
    .action(function (input, output, repoConfig) {
    path = input;
    outputPath = output;
    repoConfigPath = repoConfig;
})
    .parse(process.argv);
if (!path || !outputPath) {
    console.log('Error: The input file path and output folder path is not specified!');
    program.help();
}
outputPath = outputPath.replace(/\\/g, '/');
var repoConfig;
if (repoConfigPath && program.basePath) {
    if (fs.existsSync(repoConfigPath)) {
        var temp = JSON.parse(fs.readFileSync(repoConfigPath).toString());
        repoConfig = {
            repo: temp.repo,
            branch: temp.branch,
            basePath: program.basePath
        };
    }
    else {
        console.log("Error: repository config file path {" + repoConfigPath + "} doesn't exit!");
        program.help();
    }
}
if (!repoConfig && program.sourceUrl && program.sourceBranch) {
    repoConfig = {
        repo: program.sourceUrl,
        branch: program.sourceBranch,
        basePath: (_a = program.basePath) !== null && _a !== void 0 ? _a : ''
    };
}
flags_1.flags.hasModule = program.hasModule || false;
flags_1.flags.enableAlphabetOrder = !(program.disableAlphabetOrder || false);
flags_1.flags.tocAlphabetOrderOnly = program.tocAlphabetOrderOnly || false;
var json = null;
if (fs.existsSync(path)) {
    var dataStr = fs.readFileSync(path).toString();
    json = JSON.parse(dataStr);
}
else {
    console.error("API doc file " + path + " doesn't exist.");
    program.help();
}
var uidMapping = {};
var innerClassReferenceMapping = new Map();
var collection = [];
if (json) {
    var context = new context_1.Context(repoConfig, '', '', json.name, '', '', new Map());
    collection = new parser_1.Parser().traverse(json, uidMapping, context);
}
if (!collection || collection.length === 0) {
    console.log("Warning: nothing genereatd.");
}
var referenceMappings = [];
for (var _i = 0, collection_1 = collection; _i < collection_1.length; _i++) {
    var rootElement = collection_1[_i];
    var referenceMapping = {};
    idResolver_1.resolveInheritance(rootElement, uidMapping, referenceMapping, rootElement);
    idResolver_1.resolveIds(rootElement, uidMapping, referenceMapping, rootElement);
    referenceMappings.push(referenceMapping);
}
var rootElementsForTOC = JSON.parse(JSON.stringify(collection));
var flattenElements = collection.map(function (rootElement, index) {
    if (rootElement.uid.indexOf('constructor') >= 0) {
        return [];
    }
    return postTransformer_1.postTransform(rootElement, referenceMappings[index]);
}).reduce(function (a, b) {
    return a.concat(b);
}, []);
postTransformer_1.insertClassReferenceForModule(flattenElements);
postTransformer_1.insertLink(flattenElements);
console.log('Yaml dump start.');
fs.ensureDirSync(outputPath);
for (var _b = 0, flattenElements_1 = flattenElements; _b < flattenElements_1.length; _b++) {
    var transformedClass = flattenElements_1[_b];
    // to add this to handle duplicate class and module under the same hierachy
    postTransformer_1.insertInnerClassReference(innerClassReferenceMapping, transformedClass);
    transformedClass = JSON.parse(JSON.stringify(transformedClass));
    var filename = transformedClass.items[0].uid.replace(transformedClass.items[0].package + ".", '');
    filename = filename.split('(')[0];
    filename = filename.replace(/\//g, '.');
    console.log("Dump " + outputPath + "/" + filename + ".yml");
    fs.writeFileSync(outputPath + "/" + filename + ".yml", constants_1.yamlHeader + "\n" + serializer.safeDump(transformedClass));
}
console.log('Yaml dump end.');
var yamlModels = [];
flattenElements.forEach(function (element) {
    yamlModels.push(element.items[0]);
});
var packageIndex = packageGenerator_1.generatePackage(yamlModels);
fs.writeFileSync(outputPath + "/index.yml", constants_1.yamlHeader + "\n" + serializer.safeDump(packageIndex));
console.log('Package index generated.');
var toc = tocGenerator_1.generateTOC(rootElementsForTOC, flattenElements[0].items[0].package);
fs.writeFileSync(outputPath + "/toc.yml", serializer.safeDump(toc));
console.log('Toc generated.');
//# sourceMappingURL=main.js.map